from pyubx2 import (
    UBXMessage,
    SET_LAYER_RAM,
    SET_LAYER_FLASH,
    SET_LAYER_BBR,
    TXN_NONE,
    ATTTYPE,
    atttyp,
    UBX_CONFIG_DATABASE,
    UBX_PROTOCOL,
    UBXReader,
)
from threading import Event, Lock, Thread
from time import sleep
import serial

def read_messages(stream, lock, stop_event, ubx_reader, success_event):
    """
    Reads, parses and prints out incoming UBX messages.

    This function runs in a loop and continuously reads from the serial stream.
    It looks for UBX-ACK-ACK messages to confirm that the configuration was
    successfully applied. If an ACK is received, it sets the `success_event`.
    If a NAK is received, it indicates an error.

    Args:
        stream (Serial): The serial stream to read from.
        lock (Lock): A mutex to ensure thread-safe access to the serial stream.
        stop_event (Event): A threading event to signal when to stop.
        ubx_reader (UBXReader): The UBXReader instance for parsing messages.
        success_event (Event): A threading event to signal a successful ACK.
    """
    # pylint: disable=unused-variable, broad-except
    while not stop_event.is_set():
        if stream.in_waiting and (not success_event.is_set()):
            try:
                lock.acquire()
                _, parsed_data = ubx_reader.read()
                lock.release()
                if parsed_data and parsed_data.identity == 'ACK-ACK':
                    print(f'SUCCESS: {parsed_data}')
                    success_event.set()
                if parsed_data and parsed_data.identity == 'ACK-NAK':
                    print(f'ERROR: {parsed_data}')
            except Exception as err:
                print(f"\n\nSomething went wrong {err}\n\n")
                continue


def start_thread(stream, lock, stop_event, ubx_reader, success_event):
    """
    Starts the message reading thread.

    Args:
        stream (Serial): The serial stream to read from.
        lock (Lock): A mutex for thread-safe serial access.
        stop_event (Event): An event to signal the thread to stop.
        ubx_reader (UBXReader): The UBXReader instance for parsing messages.
        success_event (Event): An event to signal a successful ACK.

    Returns:
        Thread: The started thread instance.
    """

    thr = Thread(
        target=read_messages, args=(stream, lock, stop_event, ubx_reader, success_event), daemon=True
    )
    thr.start()
    return thr


def send_message(stream, lock, message):
    """
    Sends a message to the device.

    Args:
        stream (Serial): The serial stream to write to.
        lock (Lock): A mutex for thread-safe serial access.
        message (UBXMessage): The message to send.
    """

    lock.acquire()
    stream.write(message.serialize())
    lock.release()

def send_config(ubx_msg, port):
    """
    A helper function to send a UBX-CFG message and verify acknowledgement.

    It will send the message to the passed port, and verify a UBX-ACK-ACK
    message is received within a 1-second timeout.

    Args:
        ubx_msg (UBXMessage): The UBX-CFG message to be sent.
        port (Serial): The serial port to send the message to.

    Returns:
        bool: True if the message was acknowledged, False otherwise.

    Raises:
        RuntimeError: If no acknowledgement is received within the timeout.
    """

    # Create a UBXReader instance, reading only UBX messages.
    ubr = UBXReader(port, protfilter=UBX_PROTOCOL)

    print("\nStarting read thread...\n")
    stop_event = Event()
    stop_event.clear()
    serial_lock = Lock()
    success_event = Event()
    success_event.clear()
    read_thread = start_thread(port, serial_lock, stop_event, ubr, success_event)

    # Send the configuration message.
    print("\nSending Config Message...\n")
    send_message(port, serial_lock, ubx_msg)

    # Wait for acknowledgement.
    print("\nConfig Message was sent. Waiting for acknowledgement...\n")
    sleep(1) # An ACK message should be received within 1 second.
    success = False
    if success_event.is_set():
        success = True
    else:
        print('Sad')
        raise RuntimeError('Did not receive acknowledgement in time')

    print("\nStopping reader thread...\n")
    stop_event.set()
    read_thread.join()
    print("\nProcessing Complete")

    return success


def signed_16(value):
    """
    Converts a 16-bit hexadecimal string to a signed integer.

    Args:
        value (str): The hexadecimal string to convert.

    Returns:
        int: The signed integer representation of the hexadecimal value.
    """
    value = int(value, base=16)
    return -(value & 0x8000000000000000) | (value & 0x7fffffffffffffff)


def convert_u_center_config(config_file) -> object:
    """
    Converts a u-center configuration file (.txt) to a pyubx2 UBXMessage.

    This allows a configuration generated by the u-center software to be
    programmatically sent to a u-blox receiver.

    Args:
        config_file (str): The path to the u-center configuration file.

    Returns:
        UBXMessage: A UBX-CFG-VALSET message containing the configuration data.
    """
    cfg_data = []

    # Parse the u-center config file line by line.
    with (open(config_file, 'r') as file):
        for line in file:
            striped_line = line.strip()
            if striped_line.startswith('#'):
                continue
            split_line = striped_line.split()
            if split_line:
                layer = split_line[0]
                # Only process Flash layer for now
                if layer == 'Flash':
                    ubx_id = split_line[1].replace('-', '_') # ID's must use _
                    (key, ubx_attribute_type) = UBX_CONFIG_DATABASE[ubx_id] # Get the attribute string name
                    attribute_type = ATTTYPE[atttyp(ubx_attribute_type)] # Get the class of attribute
                    if attribute_type is bytes:
                        temp_msg = (ubx_id, int(split_line[2], 0).to_bytes()) # Must convert to bytes if ID requires it
                    elif ubx_id == 'CFG_TMODE_LON':
                        temp_msg = (ubx_id, signed_16(split_line[2])) # Negative numbers in hex work weird
                    else:
                        temp_msg = (ubx_id, int(split_line[2], 0))
                    cfg_data.append(temp_msg)

    # Create a UBX-CFG-VALSET message with the parsed configuration data.
    msg = UBXMessage.config_set(
        layers=(SET_LAYER_RAM | SET_LAYER_FLASH | SET_LAYER_BBR),
        transaction=TXN_NONE,
        cfgData=cfg_data,
    )
    print(msg)
    return msg

if __name__ == '__main__':
    # Default testing for the module.
    serial_port = serial.Serial('COM3', 9600)
    config_path = '../base-station/ntrip-caster/BS_Config.txt'
    message = convert_u_center_config(config_path)
    send_config(message, serial_port)
    serial_port.close()
