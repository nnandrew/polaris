from threading import Condition, Event
from pyubx2 import (
    UBXMessage,
    SET_LAYER_RAM,
    SET_LAYER_FLASH,
    SET_LAYER_BBR,
    TXN_NONE,
    ATTTYPE,
    atttyp,
    UBX_CONFIG_DATABASE,
)

class UBXConfig:
    
    def __init__(self, ser, ACK_TIMEOUT=1):
        """
        Initializes the UBXConfig with the provided serial port.
        
        Args:
            ser (Serial): The serial port connected to the u-blox receiver.
            ACK_TIMEOUT (int): Timeout in seconds to wait for ACK/NACK response.
        """
        
        self.ser = ser
        self.ACK_TIMEOUT = ACK_TIMEOUT
        self.ack_event = Event()
        self.nack_event = Event()
        self.reply = Condition()
        
    def set_ack(self) -> None:
        """
        Sets the ACK event to indicate a successful configuration acknowledgement.
        """
        with self.reply:
            self.ack_event.set()
            self.reply.notify()
            
    def set_nack(self):
        """
        Sets the NACK event to indicate a failed configuration acknowledgement.
        """
        with self.reply:
            self.nack_event.set()
            self.reply.notify()
            
    def _wait_for_reply(self, timeout) -> bool:
        """
        Waits for either an ACK or NACK event to be set.
        """
        with self.reply:
            self.reply.wait(timeout)
            if self.ack_event.is_set():
                self.ack_event.clear()
                return True, "Configuration applied successfully."
            if self.nack_event.is_set():
                self.nack_event.clear()
                return False, "Invalid configuration received."
        return False, "No acknowledgement received within timeout."
            
    def send_config(self, ubx_msg) -> tuple[bool, str]:
        """
        A function to send a UBX-CFG message and verify acknowledgement.

        Args:
            ubx_msg (UBXMessage): The UBX-CFG message to be sent.

        Returns:
            bool: True if the message was acknowledged, False otherwise.
            str: A message indicating the result of the operation.
        """
        
        # print("Sending Config Message...")
        self.ser.write(ubx_msg.serialize())
        self.ser.flush()

        # print("Waiting for ACK...")
        return self._wait_for_reply(self.ACK_TIMEOUT)

    @staticmethod
    def _signed_16(value) -> int:
        """
        Converts a 16-bit hexadecimal string to a signed integer.

        Args:
            value (str): The hexadecimal string to convert.

        Returns:
            int: The signed integer representation of the hexadecimal value.
        """
        value = int(value, base=16)
        return -(value & 0x8000000000000000) | (value & 0x7fffffffffffffff)

    @staticmethod
    def convert_u_center_config_from_string(config_data_str: str) -> UBXMessage:
        """
        Converts a u-center configuration string to a pyubx2 UBXMessage.
        This allows a configuration generated by the u-center software to be
        programmatically sent to a u-blox receiver from a string.
        Args:
            config_data_str (str): The u-center configuration as a string.
        Returns:
            UBXMessage: A UBX-CFG-VALSET message containing the configuration data.
        """
        cfg_data = []

        # Parse the u-center config string line by line.
        for line in config_data_str.splitlines():
            striped_line = line.strip()
            if striped_line.startswith('#'):
                continue
            split_line = striped_line.split()
            if split_line:
                layer = split_line[0]
                # Only process Flash layer for now
                if layer == 'Flash':
                    ubx_id = split_line[1].replace('-', '_') # ID's must use _
                    (key, ubx_attribute_type) = UBX_CONFIG_DATABASE[ubx_id] # Get the attribute string name
                    attribute_type = ATTTYPE[atttyp(ubx_attribute_type)] # Get the class of attribute
                    if attribute_type is bytes:
                        temp_msg = (ubx_id, int(split_line[2], 0).to_bytes(length=1, byteorder='big')) # Must convert to bytes if ID requires it
                    elif ubx_id == 'CFG_TMODE_LON':
                        temp_msg = (ubx_id, signed_16(split_line[2])) # Negative numbers in hex work weird
                    else:
                        temp_msg = (ubx_id, int(split_line[2], 0))
                    cfg_data.append(temp_msg)

        # Create a UBX-CFG-VALSET message with the parsed configuration data.
        msg = UBXMessage.config_set(
            layers=(SET_LAYER_RAM | SET_LAYER_FLASH | SET_LAYER_BBR),
            transaction=TXN_NONE,
            cfgData=cfg_data,
        )
        # print(msg)
        return msg

    @staticmethod
    def convert_u_center_config(config_file) -> UBXMessage:
        """
        Converts a u-center configuration file (.txt) to a pyubx2 UBXMessage.

        This allows a configuration generated by the u-center software to be
        programmatically sent to a u-blox receiver.

        Args:
            config_file (str): The path to the u-center configuration file.

        Returns:
            UBXMessage: A UBX-CFG-VALSET message containing the configuration data.
        """
        with open(config_file, 'r') as f:
            config_data = f.read()
        return UBXConfig.convert_u_center_config_from_string(config_data)
